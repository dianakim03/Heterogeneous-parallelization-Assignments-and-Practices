Лабораторная работа №1

Тема: Введение в основы C/C++ и структуры данных
Контрольные вопросы

1.	В чём основные отличия между массивами и динамическими структурами данных?
Ответ: Массивы имеют фиксированный размер и хранятся в непрерывной области памяти. Динамические структуры (списки, очереди) могут изменять размер и используют указатели для связи элементов.

2.	Что такое указатель, и как он используется в языке C++?
Ответ: Указатель — это переменная, которая хранит адрес другого объекта в памяти. В C++ указатели используются для работы с динамической памятью, массивами и структурами данных.

3.	Объясните принцип работы стека и очереди.
Ответ: Стек работает по принципу LIFO — последний добавленный элемент удаляется первым. Очередь работает по принципу FIFO — первый добавленный элемент удаляется первым.

4.	Каковы преимущества и недостатки односвязных списков по сравнению с массивами?
Ответ: Преимущество — лёгкое добавление и удаление элементов без перераспределения памяти. Недостатки — медленный доступ к элементам и дополнительные затраты памяти на указатели.

5.	Как правильно освобождать память в языке C++ после работы с динамическими структурами?
Ответ: Память, выделенную через new, освобождают с помощью delete, а через new[] — с помощью delete[]. Для списков необходимо удалить каждый узел отдельно.

6.	Почему важно понимать работу с указателями и динамической памятью для параллельного программирования?
Ответ: В параллельных программах несколько потоков могут одновременно обращаться к одной памяти. Неправильная работа с указателями может привести к гонкам данных и ошибкам программы.

7.	Как использовать reduction в OpenMP для нахождения суммы, минимума или максимума в массиве?
Ответ: Директива reduction создаёт локальные копии переменной для каждого потока и объединяет их в конце. Например: reduction(+:sum), reduction(min:minVal), reduction(max:maxVal).

8.	Как влияет параллельное программирование на производительность при работе с большими массивами?
Ответ: Параллельное программирование ускоряет обработку больших массивов за счёт использования нескольких ядер. Однако при малых объёмах данных накладные расходы могут сделать программу медленнее.

