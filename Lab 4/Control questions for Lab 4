Lab 4

1. Чем отличаются типы памяти в CUDA и в каких случаях их использовать?
В CUDA существует иерархия памяти, отличающаяся по скорости доступа и области видимости. Глобальная память имеет большой объём, но высокую задержку и используется для хранения основных данных. Разделяемая память работает быстрее и применяется для обмена данными между потоками одного блока, а регистры и локальная память используются для временных переменных внутри потока.

2. Как использование разделяемой памяти влияет на производительность?
Разделяемая память позволяет существенно сократить количество обращений к глобальной памяти. За счёт этого уменьшаются задержки доступа к данным и повышается производительность вычислений. Однако при неправильном использовании возможны накладные расходы на синхронизацию потоков.

3. Доступ и как его обеспечить?
Эффективный доступ к памяти обеспечивается за счёт согласованного обращения потоков к последовательным адресам глобальной памяти. Также важно корректно использовать разделяемую память внутри блока и применять синхронизацию потоков. Это снижает количество лишних транзакций памяти.

4. Какие сложности возникают при работе с большим объемом данных на GPU?
При больших объёмах данных возрастает нагрузка на глобальную память и увеличиваются задержки доступа. Также могут возникать проблемы с ограниченным объёмом разделяемой памяти и регистрами. Неправильное распределение данных может привести к снижению производительности.

5. Почему важно минимизировать доступ к глобальной памяти?
Глобальная память является самой медленной среди основных типов памяти GPU. Частые обращения к ней увеличивают общее время выполнения программы. Использование shared memory и регистров позволяет значительно сократить эти задержки.

6. Как использовать профилирование для анализа производительности CUDA-программ?
Профилирование позволяет выявить узкие места, связанные с доступом к памяти и загрузкой GPU. С помощью инструментов профилирования можно измерять время выполнения ядер и эффективность использования памяти. Это помогает понять, какие участки кода требуют оптимизации.
