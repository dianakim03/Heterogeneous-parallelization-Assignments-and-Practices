# Часть 3: Сравнение стека и очереди на GPU CUDA

В третьей части лабораторной работы выполняется сравнение двух параллельных структур данных, реализованных на GPU:  
- Стек — принцип LIFO (последний вошёл — первый вышел)  
- Очередь — принцип FIFO (первый вошёл — первый вышел)

Цель этой части — не написать новый код, а проанализировать результаты, понять в чём отличия, и объяснить как атомарные операции помогают обеспечивать корректность при параллельной работе потоков.


## Что сравнивается

1) Логика обработки данных
- Стек возвращает элементы в обратном порядке относительно добавления: последний добавленный элемент извлекается первым.
- Очередь возвращает элементы в порядке добавления: сначала извлекается самый ранний элемент.


## Используемые переменные управления

### Стек
В стеке используется одна управляющая переменная:
- `top` — вершина стека

Она увеличивается при `push` и уменьшается при `pop`.

### Очередь
В очереди используется две управляющие переменные:
- `head` — позиция чтения
- `tail` — позиция записи

Очередь требует большего контроля, потому что чтение и запись происходят через разные индексы.


## Синхронизация и атомарные операции

Обе структуры данных работают корректно в параллельном режиме за счёт атомарных операций:
- в стеке атомарно изменяется `top`
- в очереди атомарно изменяются `head` и `tail`

Атомарные операции нужны, потому что при одновременной работе потоков возможны конфликты:
- два потока могут попытаться записать в одну и ту же позицию
- два потока могут попытаться извлечь один и тот же элемент

Использование `atomicAdd` и `atomicSub` делает обновление индексов “неделимым”, поэтому каждый поток получает свою уникальную позицию.


## Как проверяется корректность по результатам программы

### Для стека (Part 1)
Корректность подтверждается следующими признаками:
- количество успешных `push` равно числу добавляемых элементов
- количество успешных `pop` равно числу извлекаемых элементов
- финальное значение `top` становится `-1`, что означает пустой стек
- первые извлечённые элементы показывают принцип LIFO

### Для очереди (Part 2)
Корректность подтверждается такими признаками:
- все операции `enqueue` и `dequeue` выполняются успешно
- финальные значения `head` и `tail` равны количеству обработанных элементов
- очередь становится пустой после извлечения всех элементов


## Наблюдения по производительности

Данные реализации являются учебными и ориентированы на корректность, однако можно сделать практические выводы:

- частые атомарные операции могут снижать производительность, особенно при большом количестве потоков
- стек обычно проще по логике, так как управляется одной переменной `top`
- очередь сложнее, так как использует два индекса и требует согласованности `head` и `tail`

Важно понимать, что в таких структурах данных производительность часто ограничивается не вычислениями, а конкуренцией потоков за общие переменные.


## Итоговый вывод

В третьей части лабораторной работы было выполнено сравнение стека и очереди, реализованных как параллельные структуры данных на GPU.  
Стек является более простым в реализации и демонстрирует поведение LIFO, а очередь реализует FIFO и требует двух управляющих индексов.  
Обе структуры данных корректно работают при параллельном доступе благодаря атомарным операциям, которые предотвращают гонки данных и обеспечивают безопасное выполнение.
