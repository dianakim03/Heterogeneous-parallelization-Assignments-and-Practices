# Task 3. Коалесцированный и некоалесцированный доступ к global memory (CUDA)

## Цель
Показать разницу в производительности между:
- коалесцированным доступом к глобальной памяти (правильный последовательный доступ),
- некоалесцированным доступом (неэффективный доступ со “скачками” по памяти).

Замер времени выполняется на массиве размером N = 1000000.

## Описание задания
В задании реализуются два CUDA-ядра, которые выполняют одну и ту же простую операцию над массивом, но читают данные из global memory по-разному:

1) Coalesced kernel
Потоки читают элементы последовательно: `a[i]`, где `i` — обычный индекс потока.  
Такой доступ хорошо оптимизируется GPU, так как обращения потоков одного варпа идут в соседние адреса памяти.

2) Non-coalesced kernel 
Потоки читают элементы со “шагом” (stride), например: `a[(i * stride) % N]`.  
Из-за этого обращения потоков не совпадают по соседним адресам, и GPU выполняет больше транзакций памяти, что обычно делает программу медленнее.

## Что делается в программе

1) Подготовка данных
- Создаётся массив `a` размером `N` на CPU.
- Массив заполняется простыми значениями для проверки.

2) Копирование на GPU
- Выделяется память для массива `d_a` на GPU.
- Данные копируются с CPU на GPU.

3) Запуск и замер времени
- Запускается coalesced kernel и измеряется время.
- Запускается non-coalesced kernel и измеряется время.
- Для честного сравнения перед каждым запуском данные приводятся к одинаковому исходному состоянию.

4) Проверка результата
- Результат копируется обратно на CPU.
- Проверяется корректность вычислений.

## Ожидаемый результат
- Время coalesced версии должно быть меньше или заметно лучше, чем у non-coalesced версии.
- Оба варианта должны выводить ok при проверке корректности.
